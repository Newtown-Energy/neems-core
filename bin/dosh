#!/usr/bin/env bash
# Do - The Simplest Build Tool on Earth.
# Documentation and examples see https://github.com/8gears/do
#
SCRIPTNAME=`basename "$0"`
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
BASEDIR=$(dirname -- "$SCRIPT_DIR")
NIGHTLY="+nightly"
DEV_TEST_FLAGS="--color=always"
CARGO=~/.cargo/bin/cargo

# Function to find the project root
_find_project_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        local base=$(basename "$dir")
        case "$base" in
            "neems-admin"|"neems-api"|"neems-data")
                echo "$dir"
                return 0
                ;;
        esac
        dir=$(dirname "$dir")
    done
    # If we get here, we're at top level
    echo "."
}

# Set DOSH_PROJ
DOSH_PROJ=$(_find_project_root)

# Set TARGET_PROJ and TARGET_BIN based on DOSH_PROJ
if [[ "$DOSH_PROJ" == "." ]]; then
    # Top level - target all projects
    PROJ_NAME="."
    export TARGET_PROJ=("-p neems-admin -p neems-api -p neems-data")
    export TARGET_BIN=("--bin neems-admin --bin neems-api --bin neems-data")
else
    # Specific project - target just this one
    PROJ_NAME=$(basename "$DOSH_PROJ")
    export TARGET_PROJ=("-p  $PROJ_NAME")
    export TARGET_BIN=("--bin  $PROJ_NAME")
fi

cd ${BASEDIR}/${PROJ_NAME}

# Check for project-specific task-override script
if [[ -n "$1" && -f "$DOSH_PROJ/bin/dosh.$1" ]]; then
    command="$1"
    shift
    echo "$DOSH_PROJ/bin/dosh.$command $@"
    exec "$DOSH_PROJ/bin/dosh.$command" "$@"
fi

if [[ ! "$DOSH_PROJ" == "." ]]; then
    # Check for task-override in project dosh
    if [[ -n "$1" && -x "$DOSH_PROJ/bin/dosh" ]]; then
        # Get the list of supported commands from the project dosh
        supported_commands=$("$DOSH_PROJ/bin/dosh" | awk '/^Usage:/,/^$/' | grep -oE '\([^)]+\)' | tr -d '()' | tr '|' ' ')

        # Check if our command is in the supported list
        if [[ " $supported_commands " =~ " $1 " ]]; then
            echo "$DOSH_PROJ/bin/dosh $@"
            exec "$DOSH_PROJ/bin/dosh" "$@"
        fi
    fi
fi

# No project-specific override of dosh command, so we handle it here.
_install-ansi2txt() {
    which ansi2txt > /dev/null && return 0
    echo Please install ansi2txt, which is available on devian in the colorized-logs package.
    return 1
}

_install-cranelift() {
    echo "➡️ Ensuring we have a Cranelift build environment..."

    rustup update

    # Check for rustup
    if ! command -v rustup >/dev/null 2>&1; then
        echo "❌ Error: rustup not found. Please install Rust first: https://rustup.rs/"
        exit 1
    fi

    # Check for nightly toolchain
    if ! rustup toolchain list | grep -q nightly; then
        echo "🔄 Nightly toolchain not found. Installing..."
        rustup toolchain install nightly
    fi

    # Check for Cranelift component
    local cranelift_path="$HOME/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/codegen-backends/librustc_codegen_cranelift-*.so"
    if [ -z "$(ls $cranelift_path 2>/dev/null)" ]; then
        echo "🔄 Cranelift backend not found. Installing..."
        rustup component add rustc-codegen-cranelift-preview --toolchain nightly

        # Verify installation succeeded
	if [ -z "$(ls $cranelift_path 2>/dev/null)" ]; then
            echo "⚠️ Cranelift installation failed. Falling back to regular build..."
            ${CARGO} build "$@"
            return
        fi
    fi
}

build() {
    # Build a dev bin

    # Build the dev project.  Don't use cranelift for release builds.
    echo "🚀 Building with Cranelift for faster dev compilation..."
    RUSTFLAGS="-Zcodegen-backend=cranelift" ${CARGO} $NIGHTLY build --features test-staging $TARGET_PROJ "$@" || {
	echo "❌ Build failed. Please check the output above."
	return 1
    }
}

check() {
    local cmd="$CARGO $NIGHTLY check $DEV_TEST_FLAGS $TARGET_PROJ"
    echo "${cmd} $@"
    if [ -z "$WAYLAND_DISPLAY" ]; then
        RUSTFLAGS="-Zcodegen-backend=cranelift" $cmd "$@" 
    else
        RUSTFLAGS="-Zcodegen-backend=cranelift" $cmd "$@" 2>&1 | tee >(ansi2txt | wl-copy)
    fi
}

run() {
    local cmd="$CARGO $NIGHTLY run $TARGET_PROJ"
    echo "${cmd} $@"
    if [ -z "$WAYLAND_DISPLAY" ]; then
        $cmd "$@"
    else
        $cmd "$@" 2>&1 | tee >(ansi2txt | wl-copy)
    fi
}

depends() {
  grep -q 'ID=debian' /etc/os-release  || {
    echo "This script is intended for Debian-based systems only."
    exit 1
  }
  set -e
  [ "$(id -u)" -eq 0 ] && { echo "Do NOT run as root. Script uses sudo as needed." >&2; exit 1; }
  sudo apt install -y colorized-logs libsqlite3-dev
  rustup update
  ${CARGO} nextest --version &> /dev/null || cargo install --locked cargo-nextest || { echo "Can't install nextest"; exit 1; }
  _install-cranelift
}

migrate() {
    echo Running migrations for neems-api

    # Install diesel command line tool
    which diesel > /dev/null || ${CARGO} binstall diesel_cli

    # Our different projects have different sqlite db envars, so commenting this
    # out for now...
    # Make sure we have a database url
    # if [ -z "$DATABASE_URL" ]; then echo "DATABASE_URL not set"; exit 0; fi

    # Create database if needed
    # [ ! -f "$DATABASE_URL" ] && diesel setup

    diesel migration run
}

nextest() {
    local cmd="${CARGO} $NIGHTLY nextest run $DEV_TEST_FLAGS $TARGET_PROJ"
    if [ -z "$WAYLAND_DISPLAY" ]; then
        RUSTFLAGS="-Zcodegen-backend=cranelift" $cmd "$@"
    else
        RUSTFLAGS="-Zcodegen-backend=cranelift" $cmd "$@" 2>&1 | tee >(ansi2txt | wl-copy)
    fi
}

push() {
    echo "Don't push from here.  Use the deploy repo."
}

release() {
    # Build a release bin
    rustup update
    echo "🚀 Building release version..."
    # The test-staging feature just makes sure we run some security tests.
    local flags="--features fixphrase --features test-staging"
    FORCE_TEST_ALL=1 ${CARGO} $NIGHTLY test --quiet --release $flags "$@" || {
	echo "❌ Tests failed. Please check the output above and junit.xml"
	exit 1
    }
    ${CARGO} $NIGHTLY build --release $flags "$@" || {
	echo "❌ Build failed. Please check the output above."
	exit 1
    }
}

test() {
    nextest "$@"
}

test-trad() {
    local cmd="${CARGO} $NIGHTLY test $DEV_TEST_FLAGS --quiet"
    if [ -z "$WAYLAND_DISPLAY" ]; then
        RUSTFLAGS="-Zcodegen-backend=cranelift" $cmd "$@"
    else
        RUSTFLAGS="-Zcodegen-backend=cranelift" $cmd "$@" 2>&1 | tee >(ansi2txt | wl-copy)
    fi
}


watch() {
    echo "Running Neems Core for development purposes..."
    ${CARGO} --list | grep -Eq '^    watch$' || cargo install cargo-watch

    # Maybe copy our test db to /tmp
    [ -f neems-api.sqlite ] && cp neems-api.sqlite /tmp

    ${CARGO} watch --ignore "neems-api.sqlite*" -x run
}

# If this script is called as cargo, let it act as a cargo wrapper, even for
# cargo commands we haven't expicitly wrapped.  This is useful for when llm
# agents insist on running their own cargo commands
if [ $SCRIPTNAME = "cargo" ]; then
    if ! declare -F "$1" 2> /dev/null > /dev/null; then
    if [[ "$1" =~ ^- ]] || $CARGO --list | grep -q " *$1" ; then 
            $CARGO "$@"
            exit
        fi
    fi
fi

# If this script is called as dosh OR as cargo and we have a function that
# matches, run it.  If we are dosh, complain if the command isn't found.
"$@" # <- execute the task

# If this script is called as dosh but not args are provided, print usage
[ "$#" -gt 0 ] || printf "Usage:\n\t./${SCRIPTNAME} %s\n" "($(compgen -A function | grep '^[^_]' | paste -sd '|' -))"
